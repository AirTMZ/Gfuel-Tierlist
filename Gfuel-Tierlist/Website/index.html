<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>G-Fuel Tier List</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@shopify/draggable@1.0.0-beta.8/lib/draggable.bundle.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crc-32/1.2.0/crc32.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

  <style>
    .tier-row {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      overflow-x: auto;
      padding-bottom: 10px;
    }

    .label-holder {
      width: 50px;
      text-align: center;
      padding: 0.5rem;
      border-radius: 0.375rem;
      margin-right: 0.5rem;
      flex-shrink: 0;
    }

    .tier {
      flex: 1;
      min-height: 100px;
      border: 1px solid #4a5568;
      border-radius: 0.375rem;
      padding: 0.5rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      background-color: #2d3748;
      transition: background-color 0.2s;
      position: relative;
    }

    .tier.drop-active {
      background-color: #4a5568;
    }

    .tier-item,
    .pool-item {
      background-color: #2d3748;
      padding: 0.5rem;
      border-radius: 0.375rem;
      cursor: grab;
      width: 100px;
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      touch-action: none;
    }

    .tier-item img,
    .pool-item img {
      max-width: 100%;
      max-height: 100%;
      border-radius: 0.375rem;
    }

    .pool {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 1rem;
      border: 1px solid #4a5568;
      border-radius: 0.375rem;
      background-color: #1a202c;
      justify-content: center;
      position: relative;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 1rem;
    }

    .header.with-back-button {
      justify-content: space-between;
    }

    .header h1 {
      margin: 0;
    }

    .header p {
      margin: 0;
      color: #a0aec0;
    }

    .draggable-mirror {
      z-index: 9999;
      opacity: 0.9;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      position: fixed;
    }

    .draggable-source--is-dragging {
      opacity: 0.3;
    }

    .draggable-container--over {
      background-color: rgba(74, 85, 104, 0.5);
    }
  </style>
</head>

<body class="bg-gray-900 text-white min-h-screen">
  <div class="p-6 max-w-4xl mx-auto">
    <div id="header" class="header">
      <!-- Back button to return from editing state -->
      <button id="backButton" onclick="goBack()" class="hidden bg-red-600 px-4 py-2 rounded">Back</button>
      <div class="text-center">
        <h1 class="text-4xl font-extrabold">G-Fuel Tier List</h1>
        <p>Only rank the flavors you've tried.</p>
      </div>
    </div>

    <!-- Initial input for loading or starting a new tier list -->
    <div id="initialControls" class="mb-4 flex flex-col items-center">
      <input type="text" placeholder="Enter tier list code" id="inputCode"
        class="border p-2 w-80 mb-2 bg-gray-800 text-white text-center">
      <div class="flex gap-4">
        <button onclick="loadFromCode()" class="bg-blue-600 px-4 py-2 rounded">Load from Code</button>
        <button onclick="startEditing()" class="bg-green-600 px-4 py-2 rounded">New Tier List</button>
      </div>
    </div>

    <!-- Main container for displaying tiers -->
    <div id="tierContainer" class="hidden mb-4"></div>
    <!-- Pool area for unassigned flavors -->
    <div id="poolArea" class="pool hidden"></div>
    <!-- Buttons for generating the code after editing -->
    <div id="codeButtons" class="hidden mt-6 text-center">
      <button onclick="generateCode()" class="bg-green-600 text-white font-bold px-4 py-2 rounded">
        Save and Generate Code
      </button>
    </div>
  </div>

  <script>
    // All defined tiers and their associated colors
    const TIERS = [
      { name: "S", color: "rgb(255, 127, 127)" },
      { name: "A", color: "rgb(255, 191, 127)" },
      { name: "B", color: "rgb(255, 223, 127)" },
      { name: "C", color: "rgb(255, 255, 127)" },
      { name: "D", color: "rgb(191, 255, 127)" },
      { name: "F", color: "rgb(127, 255, 127)" },
    ];

    let tierList = {};
    let flavors = [];
    let isEditing = false;
    let draggableInstance = null;

    // Load flavor data, set up empty tier list, then render
    async function fetchFlavors() {
      try {
        const response = await fetch("gfuel_flavors.json");
        flavors = await response.json();
        console.log("Flavors loaded:", flavors);
      } catch (error) {
        console.log("Failed to load flavors, using dummy data");
        flavors = [
          { name: "Blue Ice", image: "https://via.placeholder.com/100?text=Blue+Ice" },
          { name: "Tropical Rain", image: "https://via.placeholder.com/100?text=Tropical+Rain" },
          { name: "Sour Cherry", image: "https://via.placeholder.com/100?text=Sour+Cherry" },
          { name: "Strawberry Banana", image: "https://via.placeholder.com/100?text=Strawberry" },
          { name: "Watermelon", image: "https://via.placeholder.com/100?text=Watermelon" },
          { name: "Rainbow Sherbet", image: "https://via.placeholder.com/100?text=Rainbow" }
        ];
      }
      tierList = TIERS.reduce((acc, tier) => {
        acc[tier.name] = [];
        return acc;
      }, {});
      renderTierList();
    }

    // Load a previously saved tier list from a code
    async function loadFromCode() {
      const inputCode = document.getElementById("inputCode").value;
      if (!inputCode) {
        Swal.fire({ icon: 'error', title: 'Oops...', text: 'Please enter a valid code' });
        return;
      }
      tierList = TIERS.reduce((acc, tier) => {
        acc[tier.name] = [];
        return acc;
      }, {});
      try {
        const compactCode = atob(inputCode);
        const idFlavorMap = {};
        flavors.forEach(flavor => {
          if (flavor.image_id) {
            idFlavorMap[flavor.image_id] = flavor.name;
          }
        });
        const tierRegex = /([SABCDF])(\d+)/g;
        let match;
        while ((match = tierRegex.exec(compactCode)) !== null) {
          const tier = match[1];
          const idsChunk = match[2];
          const idLength = 10;
          for (let i = 0; i < idsChunk.length; i += idLength) {
            const id = idsChunk.substr(i, idLength);
            const flavorName = idFlavorMap[id];
            if (flavorName && TIERS.some(t => t.name === tier)) {
              tierList[tier].push(flavorName);
            }
          }
        }
        isEditing = true;
        renderTierList();
        Swal.fire('Tier list loaded!');
      } catch (error) {
        console.error("Error loading code:", error);
        Swal.fire({
          icon: 'error',
          title: 'Invalid Code',
          text: 'The provided code could not be parsed correctly.'
        });
      }
    }

    // Create a new empty tier list for editing
    function startEditing() {
      isEditing = true;
      tierList = TIERS.reduce((acc, tier) => {
        acc[tier.name] = [];
        return acc;
      }, {});
      renderTierList();
    }

    // Generate a shareable code for the current tier arrangement
    function generateCode() {
      const flavorIdMap = {};
      flavors.forEach(flavor => {
        if (flavor.image_id) {
          flavorIdMap[flavor.name] = flavor.image_id;
        }
      });
      let compactCode = '';
      for (const tier of TIERS) {
        const tierItems = tierList[tier.name] || [];
        if (tierItems.length > 0) {
          compactCode += tier.name;
          tierItems.forEach(item => {
            const id = flavorIdMap[item];
            if (id) compactCode += id;
          });
        }
      }
      const encodedCode = btoa(compactCode);
      navigator.clipboard.writeText(encodedCode);
      Swal.fire({
        icon: 'success',
        title: 'Tier List Saved!',
        html: `<div class="text-center">
                <p>Your tier list code is:</p>
                <p class="text-2xl font-bold mt-2 mb-4">${encodedCode}</p>
                <p class="text-sm">Code has been copied to clipboard</p>
              </div>`,
        confirmButtonText: 'OK',
        confirmButtonColor: '#10B981',
      });
    }

    // Render the tiers and pool, toggling editing state
    function renderTierList() {
      const tierContainer = document.getElementById("tierContainer");
      const poolArea = document.getElementById("poolArea");
      const codeButtons = document.getElementById("codeButtons");
      const initialControls = document.getElementById("initialControls");
      const backButton = document.getElementById("backButton");
      const header = document.getElementById("header");

      // Destroy existing Draggable instance if it exists
      if (draggableInstance) {
        draggableInstance.destroy();
        draggableInstance = null;
      }

      tierContainer.innerHTML = "";
      poolArea.innerHTML = "";

      if (isEditing) {
        tierContainer.classList.remove("hidden");
        poolArea.classList.remove("hidden");
        codeButtons.classList.remove("hidden");
        initialControls.classList.add("hidden");
        backButton.classList.remove("hidden");
        header.classList.add("with-back-button");

        // Create a row for each tier
        TIERS.forEach(({ name, color }) => {
          const row = document.createElement("div");
          row.className = "tier-row";
          row.innerHTML = `
            <div class="label-holder" style="background-color: ${color};">
              <span class="label">${name}</span>
            </div>
            <div class="tier" data-tier="${name}"></div>
          `;
          tierContainer.appendChild(row);
        });

        // Keep track of used flavors so we know what should remain in the pool
        const usedFlavors = new Set();

        // Add existing sorted flavors to their tiers
        for (const tier in tierList) {
          const tierEl = document.querySelector(`.tier[data-tier="${tier}"]`);
          tierList[tier].forEach(flavorName => {
            const flavor = flavors.find(f => f.name === flavorName);
            if (flavor) {
              const itemDiv = document.createElement("div");
              itemDiv.className = "tier-item";
              itemDiv.dataset.name = flavor.name;
              itemDiv.innerHTML = `<img src="images/${flavor.image}" alt="${flavor.name}">`;
              tierEl.appendChild(itemDiv);
              usedFlavors.add(flavor.name);
            }
          });
        }

        // Anything unused stays in the pool
        flavors.forEach(flavor => {
          if (!usedFlavors.has(flavor.name)) {
            const itemDiv = document.createElement("div");
            itemDiv.className = "pool-item";
            itemDiv.dataset.name = flavor.name;
            itemDiv.innerHTML = `<img src="images/${flavor.image}" alt="${flavor.name}">`;
            poolArea.appendChild(itemDiv);
          }
        });

        setupDraggable();
      } else {
        tierContainer.classList.add("hidden");
        poolArea.classList.add("hidden");
        codeButtons.classList.add("hidden");
        initialControls.classList.remove("hidden");
        backButton.classList.add("hidden");
        header.classList.remove("with-back-button");
      }
    }

    // Set up Shopify Draggable
    function setupDraggable() {
      // Define all containers that will participate in drag/drop operations
      const containers = [
        ...document.querySelectorAll('.tier'),
        document.querySelector('.pool')
      ];

      // Initialize Draggable
      draggableInstance = new Draggable.Sortable(containers, {
        draggable: '.tier-item, .pool-item',
        mirror: {
          appendTo: 'body',
          constrainDimensions: true
        },
        plugins: [Draggable.Plugins.ResizeMirror]
      });

      // Handle drag start
      draggableInstance.on('drag:start', (event) => {
        document.body.style.cursor = 'grabbing';
      });

      // Handle drag stop
      draggableInstance.on('drag:stop', (event) => {
        document.body.style.cursor = '';
      });

      // Handle sorting between containers
      draggableInstance.on('sortable:sorted', (event) => {
        updateTierList();
      });

      // Update class when dragging over container
      draggableInstance.on('sortable:over', (event) => {
        event.overContainer.classList.add('drop-active');
      });

      // Remove class when dragging out of container
      draggableInstance.on('sortable:out', (event) => {
        event.overContainer.classList.remove('drop-active');
      });

      // Make sure items maintain correct class based on their container
      draggableInstance.on('sortable:stop', (event) => {
        const allContainers = document.querySelectorAll('.tier, .pool');
        allContainers.forEach(container => {
          container.classList.remove('drop-active');
        });

        // Update classes based on container
        const poolItems = document.querySelectorAll('.pool .tier-item');
        poolItems.forEach(item => {
          item.classList.remove('tier-item');
          item.classList.add('pool-item');
        });

        const tierItems = document.querySelectorAll('.tier .pool-item');
        tierItems.forEach(item => {
          item.classList.remove('pool-item');
          item.classList.add('tier-item');
        });
      });
    }

    // Update the tierList object based on current DOM arrangement
    function updateTierList() {
      // Reset the tierList
      TIERS.forEach(tier => {
        tierList[tier.name] = [];
      });

      // Update it based on the current DOM arrangement
      TIERS.forEach(tier => {
        const tierElement = document.querySelector(`.tier[data-tier="${tier.name}"]`);
        const items = tierElement.querySelectorAll('.tier-item, .pool-item');
        items.forEach(item => {
          tierList[tier.name].push(item.dataset.name);
        });
      });
    }

    // Go back to initial screen
    function goBack() {
      isEditing = false;
      renderTierList();
    }

    // Start by fetching flavors
    document.addEventListener("DOMContentLoaded", fetchFlavors);
  </script>
</body>

</html>